import { createServer, type Server, type IncomingMessage, type ServerResponse } from "node:http";
import { createReadStream, existsSync, statSync } from "node:fs";
import { join, extname, resolve } from "node:path";
import { createHash } from "node:crypto";
import { WebSocketServer, WebSocket } from "ws";
import { writeFileSync } from "node:fs";
import type { ServerConfig, WebhookHandler, ActivityEntry } from "./types.js";
import type { ConfigWatcher } from "./config-watcher.js";
import type { WorkspaceFiles } from "./vault/files.js";
import { FilePathError, FileNotFoundError } from "./vault/files.js";
import { redactConfig, mergeConfig, serializeConfig, loadConfig } from "./config.js";
import * as logger from "./logger.js";

export interface SessionStateInfo {
    name: string;
    state: string;
    model?: string;
    contextSize?: number;
    lastActivity?: number;
}

export interface DashboardProvider {
    getUptime(): number;
    getStartedAt(): number;
    getModel(): string;
    getContextSize(): number;
    getListenerCount(): number;
    getCronJobs(): Array<{ name: string; schedule: string; enabled: boolean }>;
    getUsage(): {
        today: { inputTokens: number; outputTokens: number; cost: number; messageCount: number };
        week: { cost: number };
        contextSize: number;
    };
    getActivity(): ActivityEntry[];
    getLogs(): Array<{ timestamp: string; level: string; message: string; [key: string]: unknown }>;
    getSessionNames(): string[];
    getSessionState(name: string): SessionStateInfo | null;
    getUsageBySession(name: string): {
        today: { inputTokens: number; outputTokens: number; cost: number; messageCount: number };
    } | null;
}

const MIME_TYPES: Record<string, string> = {
    ".html": "text/html",
    ".css": "text/css",
    ".js": "application/javascript",
    ".json": "application/json",
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".svg": "image/svg+xml",
    ".ico": "image/x-icon",
};

const WEBHOOK_RATE_WINDOW_MS = 60_000;
const WEBHOOK_RATE_MAX = 10;
const WEBHOOK_GLOBAL_RATE_MAX = 30;
const WEBHOOK_GLOBAL_BUCKET = "__global__";

const AUTH_RATE_WINDOW_MS = 60_000;
const AUTH_RATE_MAX = 10;

type RouteHandler = (req: IncomingMessage, res: ServerResponse) => void | Promise<void>;
export type WsRpcHandler = (message: { type: string; [key: string]: unknown }, clientId: string) => Promise<any>;

export class HttpServer {
    private server: Server;
    private config: ServerConfig;
    private publicDir: string;
    private startTime: number;
    private routes = new Map<string, Map<string, RouteHandler>>();
    private webhookHandler?: WebhookHandler;
    private configWatcher?: ConfigWatcher;
    private configPath?: string;
    private webhookRateLimits = new Map<string, number[]>();
    private authRateLimits = new Map<string, number[]>();
    private dashboard: DashboardProvider | null;
    private wss: WebSocketServer;
    private wsClients = new Map<string, WebSocket>();
    private wsClientCounter = 0;
    private wsHandler?: WsRpcHandler;
    private workspaceFiles?: WorkspaceFiles;
    private prefixRoutes: Array<{ prefix: string; method: string; handler: RouteHandler }> = [];

    constructor(config: ServerConfig, dashboard?: DashboardProvider) {
        this.config = config;
        this.dashboard = dashboard ?? null;
        this.publicDir = config.publicDir
            ? resolve(config.publicDir)
            : resolve("public");
        this.startTime = Date.now();

        this.server = createServer((req, res) => this.handleRequest(req, res));
        this.server.on("upgrade", (req, socket, head) => this.handleUpgrade(req, socket, head));
        this.wss = new WebSocketServer({ noServer: true });

        this.registerRoutes();
    }

    /** Expose the underlying http.Server for testing */
    get raw(): Server {
        return this.server;
    }

    /** Number of connected WebSocket clients */
    get wsClientCount(): number {
        return this.wsClients.size;
    }

    /** Set the handler for incoming WebSocket RPC commands */
    setWsHandler(handler: WsRpcHandler): void {
        this.wsHandler = handler;
    }

    /** Broadcast a bridge event to all connected WebSocket clients */
    broadcastEvent(event: any): void {
        if (this.wsClients.size === 0) return;
        const data = JSON.stringify(event);
        for (const [, client] of this.wsClients) {
            if (client.readyState === WebSocket.OPEN) {
                client.send(data);
            }
        }
    }

    /** Send an event to a specific WebSocket client by ID */
    sendToClient(clientId: string, event: any): void {
        const client = this.wsClients.get(clientId);
        if (client && client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify(event));
        }
    }

    async start(): Promise<void> {
        return new Promise((resolve, reject) => {
            this.server.once("error", reject);
            this.server.listen(this.config.port, "0.0.0.0", () => {
                this.server.removeListener("error", reject);
                logger.info("HTTP server listening", { port: this.config.port });
                resolve();
            });
        });
    }

    async stop(): Promise<void> {
        // Close all WebSocket connections first
        for (const [, client] of this.wsClients) {
            client.close(1001, "Server shutting down");
        }
        this.wsClients.clear();

        return new Promise((resolve) => {
            const timeout = setTimeout(() => {
                this.server.closeAllConnections();
            }, 5000);
            this.server.close(() => {
                clearTimeout(timeout);
                logger.info("HTTP server stopped");
                resolve();
            });
            this.server.closeIdleConnections();
        });
    }

    setWebhookHandler(handler: WebhookHandler): void {
        this.webhookHandler = handler;
    }

    setConfigWatcher(watcher: ConfigWatcher, configPath: string): void {
        this.configWatcher = watcher;
        this.configPath = configPath;
    }

    setFiles(files: WorkspaceFiles): void {
        this.workspaceFiles = files;
        this.registerFileRoutes();
    }



    private prefixRoute(method: string, prefix: string, handler: RouteHandler): void {
        this.prefixRoutes.push({ prefix, method, handler });
    }

    private registerFileRoutes(): void {
        // List configured roots
        this.route("GET", "/api/roots", async (_req, res) => {
            const roots = this.workspaceFiles!.getRootNames();
            this.json(res, 200, { roots });
        });

        // List files — requires ?root=name
        this.route("GET", "/api/files", async (req, res) => {
            const url = new URL(req.url ?? "/", "http://localhost");
            const root = url.searchParams.get("root");
            const dir = url.searchParams.get("dir") ?? undefined;
            const search = url.searchParams.get("search") ?? undefined;

            if (!root) {
                this.json(res, 400, { error: "Missing required 'root' parameter" });
                return;
            }

            try {
                const entries = await this.workspaceFiles!.listFiles(root, dir, search);
                this.json(res, 200, { entries });
            } catch (err) {
                this.handleFileError(res, err);
            }
        });

        // Move file — requires root in body
        this.route("POST", "/api/files/move", async (req, res) => {
            let body: any;
            try {
                body = await this.readJsonBody(req);
            } catch {
                this.json(res, 400, { error: "Invalid JSON body" });
                return;
            }

            if (!body || typeof body.root !== "string" || typeof body.from !== "string" || typeof body.to !== "string") {
                this.json(res, 400, { error: "Body must include 'root', 'from', and 'to' strings" });
                return;
            }

            if (!body.from.trim() || !body.to.trim()) {
                this.json(res, 400, { error: "Paths cannot be empty" });
                return;
            }

            try {
                await this.workspaceFiles!.moveFile(body.root, body.from, body.to);
                this.json(res, 200, { ok: true, from: body.from, to: body.to });
            } catch (err) {
                this.handleFileError(res, err);
            }
        });

        // Read file: /api/files/:root/:path...
        this.prefixRoute("GET", "/api/files/", async (req, res) => {
            const parsed = this.extractRootAndPath(req.url ?? "");
            if (!parsed) {
                this.json(res, 400, { error: "Missing root and file path" });
                return;
            }
            const { root, filePath } = parsed;

            const url = new URL(req.url ?? "/", "http://localhost");
            if (url.searchParams.get("raw") === "true") {
                try {
                    const result = await this.workspaceFiles!.readFileRaw(root, filePath);
                    const headers: Record<string, string | number> = {
                        "Content-Type": result.mimeType,
                        "Content-Length": result.buffer.length,
                        "X-Content-Type-Options": "nosniff",
                    };
                    if (result.mimeType === "image/svg+xml") {
                        headers["Content-Security-Policy"] = "default-src 'none'; style-src 'unsafe-inline'";
                    }
                    res.writeHead(200, headers);
                    res.end(result.buffer);
                } catch (err) {
                    this.handleFileError(res, err);
                }
                return;
            }

            try {
                const result = await this.workspaceFiles!.readFile(root, filePath);
                this.json(res, 200, result);
            } catch (err) {
                this.handleFileError(res, err);
            }
        });

        // Write file: /api/files/:root/:path...
        this.prefixRoute("PUT", "/api/files/", async (req, res) => {
            const parsed = this.extractRootAndPath(req.url ?? "");
            if (!parsed) {
                this.json(res, 400, { error: "Missing root and file path" });
                return;
            }
            const { root, filePath } = parsed;

            let body: any;
            try {
                body = await this.readJsonBody(req);
            } catch {
                this.json(res, 400, { error: "Invalid JSON body" });
                return;
            }

            if (!body || typeof body.content !== "string") {
                this.json(res, 400, { error: "Body must include 'content' string" });
                return;
            }

            try {
                await this.workspaceFiles!.writeFile(root, filePath, body.content);
                this.json(res, 200, { ok: true, path: filePath });
            } catch (err) {
                this.handleFileError(res, err);
            }
        });

        // Delete file: /api/files/:root/:path...
        this.prefixRoute("DELETE", "/api/files/", async (req, res) => {
            const parsed = this.extractRootAndPath(req.url ?? "");
            if (!parsed) {
                this.json(res, 400, { error: "Missing root and file path" });
                return;
            }
            const { root, filePath } = parsed;

            try {
                await this.workspaceFiles!.deleteFile(root, filePath);
                this.json(res, 200, { ok: true, path: filePath });
            } catch (err) {
                this.handleFileError(res, err);
            }
        });
    }

    /** Extract root name and file path from /api/files/:root/:path... */
    private extractRootAndPath(rawUrl: string): { root: string; filePath: string } | null {
        const url = new URL(rawUrl, "http://localhost");
        const prefix = "/api/files/";
        if (!url.pathname.startsWith(prefix)) return null;
        const rest = decodeURIComponent(url.pathname.slice(prefix.length));
        if (!rest) return null;
        const slashIdx = rest.indexOf("/");
        if (slashIdx === -1) return null;
        const root = rest.slice(0, slashIdx);
        const filePath = rest.slice(slashIdx + 1);
        if (!root || !filePath) return null;
        return { root, filePath };
    }

    private handleFileError(res: ServerResponse, err: unknown): void {
        if (err instanceof FilePathError) {
            const status = err.message.includes("is a directory") ? 400 : 403;
            this.json(res, status, { error: err.message });
        } else if (err instanceof FileNotFoundError) {
            this.json(res, 404, { error: err.message });
        } else {
            logger.error("File error", { error: String(err) });
            this.json(res, 500, { error: "Internal server error" });
        }
    }

    private registerRoutes(): void {
        this.route("GET", "/api/ping", (_req, res) => {
            this.json(res, 200, { pong: true });
        });

        this.route("GET", "/api/status", (_req, res) => {
            if (this.dashboard) {
                this.json(res, 200, {
                    ok: true,
                    uptime: Math.floor(this.dashboard.getUptime() / 1000),
                    startedAt: new Date(this.dashboard.getStartedAt()).toISOString(),
                    model: this.dashboard.getModel(),
                    contextSize: this.dashboard.getContextSize(),
                    listenerCount: this.dashboard.getListenerCount(),
                    sessions: this.dashboard.getSessionNames(),
                });
            } else {
                this.json(res, 200, {
                    ok: true,
                    uptime: Math.floor((Date.now() - this.startTime) / 1000),
                    startedAt: new Date(this.startTime).toISOString(),
                });
            }
        });

        this.route("GET", "/api/sessions", (_req, res) => {
            if (!this.dashboard) {
                this.json(res, 200, { sessions: [] });
                return;
            }
            const names = this.dashboard.getSessionNames();
            const sessions = names.map((name) => {
                try {
                    const state = this.dashboard!.getSessionState(name);
                    const usage = this.dashboard!.getUsageBySession(name);
                    return {
                        name,
                        state: state?.state ?? "unknown",
                        model: state?.model,
                        contextSize: state?.contextSize,
                        lastActivity: state?.lastActivity,
                        today: usage?.today ?? null,
                    };
                } catch (err) {
                    logger.warn("Failed to get session info", { name, error: String(err) });
                    return { name, state: "error", model: null, contextSize: null, lastActivity: null, today: null };
                }
            });
            this.json(res, 200, { sessions });
        });

        this.route("GET", "/api/cron", (_req, res) => {
            if (!this.dashboard) {
                this.json(res, 200, { jobs: [] });
                return;
            }
            this.json(res, 200, { jobs: this.dashboard.getCronJobs() });
        });

        this.route("GET", "/api/usage", (req, res) => {
            if (!this.dashboard) {
                this.json(res, 200, {
                    today: { inputTokens: 0, outputTokens: 0, cost: 0, messageCount: 0 },
                    week: { cost: 0 },
                    contextSize: 0,
                });
                return;
            }

            // Support ?session=<name> for per-session usage
            const url = new URL(req.url ?? "/", "http://localhost");
            const sessionParam = url.searchParams.get("session");
            if (sessionParam && this.dashboard.getUsageBySession) {
                const sessionUsage = this.dashboard.getUsageBySession(sessionParam);
                if (!sessionUsage) {
                    this.json(res, 404, { error: `Unknown session: ${sessionParam}` });
                    return;
                }
                this.json(res, 200, { today: sessionUsage.today, session: sessionParam });
                return;
            }

            this.json(res, 200, this.dashboard.getUsage());
        });

        this.route("GET", "/api/activity", (_req, res) => {
            if (!this.dashboard) {
                this.json(res, 200, { entries: [] });
                return;
            }
            this.json(res, 200, { entries: this.dashboard.getActivity() });
        });

        this.route("GET", "/api/logs", (_req, res) => {
            if (!this.dashboard) {
                this.json(res, 200, { entries: [] });
                return;
            }
            this.json(res, 200, { entries: this.dashboard.getLogs() });
        });

        // ─── Config API ────────────────────────────────────────────

        this.route("GET", "/api/config", (_req, res) => {
            if (!this.configWatcher) {
                this.json(res, 503, { error: "Config watcher not configured" });
                return;
            }
            const config = this.configWatcher.getCurrentConfig();
            this.json(res, 200, redactConfig(config));
        });

        this.route("POST", "/api/config", async (req, res) => {
            if (!this.configWatcher || !this.configPath) {
                this.json(res, 503, { error: "Config watcher not configured" });
                return;
            }

            let body: Record<string, unknown>;
            try {
                body = await this.readJsonBody(req);
            } catch {
                this.json(res, 400, { error: "Invalid JSON body" });
                return;
            }

            if (!body || typeof body !== "object" || Array.isArray(body)) {
                this.json(res, 400, { error: "Body must be a JSON object" });
                return;
            }

            try {
                const current = this.configWatcher.getCurrentConfig();
                const merged = mergeConfig(current, body);

                // Validate by round-tripping through loadConfig-style validation
                // Write to file first, then let the watcher pick up the change
                const yamlStr = serializeConfig(merged);
                writeFileSync(this.configPath, yamlStr, "utf-8");

                // Validate the written file can be loaded (catches env var issues etc.)
                loadConfig(this.configPath);

                logger.info("Config updated via API", { sections: Object.keys(body) });
                this.json(res, 200, { ok: true, config: redactConfig(merged) });
            } catch (err) {
                logger.error("Config API update failed", { error: String(err) });
                this.json(res, 400, { error: "Invalid config format. Check server logs for details." });
            }
        });

        this.route("POST", "/api/webhook", async (req, res) => {
            if (!this.webhookHandler) {
                this.json(res, 503, { error: "Webhook handler not configured" });
                return;
            }

            let body: any;
            try {
                body = await this.readJsonBody(req);
            } catch {
                this.json(res, 400, { error: "Invalid JSON body" });
                return;
            }

            if (!body || typeof body.message !== "string" || !body.message.trim()) {
                this.json(res, 400, { error: "Missing required field: message" });
                return;
            }

            // Validate session exists BEFORE rate limiting so invalid
            // sessions don't consume rate limit quota
            if (body.session && typeof body.session === "string" && this.dashboard) {
                const validSessions = this.dashboard.getSessionNames();
                if (!validSessions.includes(body.session)) {
                    this.json(res, 400, { error: `Unknown session: ${body.session}` });
                    return;
                }
            }

            // Global rate limit first (prevents bypass via many source values)
            if (this.isWebhookRateLimited(WEBHOOK_GLOBAL_BUCKET, WEBHOOK_GLOBAL_RATE_MAX)) {
                this.json(res, 429, { error: "Rate limit exceeded" });
                return;
            }

            // Per-source rate limit
            const rateBucket = body.source ?? "webhook";
            if (this.isWebhookRateLimited(rateBucket, WEBHOOK_RATE_MAX)) {
                this.json(res, 429, { error: "Rate limit exceeded" });
                return;
            }

            try {
                const result = await this.webhookHandler({
                    message: body.message,
                    notify: body.notify,
                    source: body.source,
                    session: body.session,
                });

                const status = result.queued ? 202 : 200;
                this.json(res, status, result);
            } catch (err) {
                logger.error("Webhook handler error", { error: String(err) });
                this.json(res, 500, { error: "Internal server error" });
            }
        });
    }

    private route(method: string, path: string, handler: RouteHandler): void {
        if (!this.routes.has(path)) {
            this.routes.set(path, new Map());
        }
        this.routes.get(path)!.set(method, handler);
    }

    /** Extract real client IP, respecting reverse proxy headers */
    private getClientIp(req: IncomingMessage): string {
        // X-Forwarded-For: leftmost entry is the original client
        const xff = req.headers["x-forwarded-for"];
        if (xff) {
            const first = (Array.isArray(xff) ? xff[0] : xff).split(",")[0].trim();
            if (first) return first;
        }
        // X-Real-IP: single IP set by some proxies (e.g. nginx)
        const xri = req.headers["x-real-ip"];
        if (xri) {
            const ip = Array.isArray(xri) ? xri[0] : xri;
            if (ip) return ip;
        }
        return req.socket.remoteAddress ?? "unknown";
    }

    private async handleRequest(req: IncomingMessage, res: ServerResponse): Promise<void> {
        const url = new URL(req.url ?? "/", `http://localhost`);
        const pathname = url.pathname;

        // Health endpoint — no auth required
        if (pathname === "/health" && (req.method ?? "GET") === "GET") {
            this.json(res, 200, { status: "ok" });
            return;
        }

        // CORS preflight — no auth required
        if (req.method === "OPTIONS" && this.config.cors) {
            this.setCorsHeaders(res);
            res.writeHead(204);
            res.end();
            return;
        }

        // Per-IP rate limiting on auth failures
        const clientIp = this.getClientIp(req);
        if (this.isAuthRateLimited(clientIp)) {
            this.json(res, 429, { error: "Too many failed auth attempts. Try again later." });
            return;
        }

        // API and attach routes require auth
        if (pathname.startsWith("/api/") || pathname === "/attach") {
            if (!this.authenticate(req)) {
                this.recordAuthFailure(clientIp);
                this.json(res, 401, { error: "Unauthorized" });
                return;
            }
        }

        // Set CORS headers on all responses if configured
        if (this.config.cors) {
            this.setCorsHeaders(res);
        }

        // Check registered routes (exact match)
        const methods = this.routes.get(pathname);
        if (methods) {
            const handler = methods.get(req.method ?? "GET");
            if (handler) {
                try {
                    const result = handler(req, res);
                    if (result instanceof Promise) {
                        await result;
                    }
                } catch (err) {
                    logger.error("Route handler error", { path: pathname, error: String(err) });
                    if (!res.headersSent) {
                        this.json(res, 500, { error: "Internal server error" });
                    }
                }
                return;
            }
            // Path exists but wrong method
            res.writeHead(405, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ error: "Method Not Allowed" }));
            return;
        }

        // Check prefix routes (wildcard path matching)
        for (const route of this.prefixRoutes) {
            if (pathname.startsWith(route.prefix) && (req.method ?? "GET") === route.method) {
                try {
                    const result = route.handler(req, res);
                    if (result instanceof Promise) {
                        await result;
                    }
                } catch (err) {
                    logger.error("Route handler error", { path: pathname, error: String(err) });
                    if (!res.headersSent) {
                        this.json(res, 500, { error: "Internal server error" });
                    }
                }
                return;
            }
        }

        // Static file serving for non-API paths
        if (!pathname.startsWith("/api/") && pathname !== "/attach") {
            this.serveStatic(pathname, res);
            return;
        }

        this.json(res, 404, { error: "Not Found" });
    }

    private handleUpgrade(req: IncomingMessage, socket: import("node:stream").Duplex, head: Buffer): void {
        const url = new URL(req.url ?? "/", `http://localhost`);

        if (url.pathname !== "/attach") {
            socket.write("HTTP/1.1 404 Not Found\r\n\r\n");
            socket.destroy();
            return;
        }

        // If Authorization header is present, authenticate immediately (TUI/programmatic clients)
        const headerAuth = this.authenticate(req);

        this.wss.handleUpgrade(req, socket, head, (ws) => {
            const clientId = `ws-${++this.wsClientCounter}`;
            let authenticated = headerAuth;

            // Keep-alive: ping every 30s so proxies/NAT don't drop idle connections.
            // The ws package handles pong responses automatically.
            const pingInterval = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) ws.ping();
            }, 30_000);

            // If not pre-authenticated via header, require first-message auth within 5s
            let authTimeout: ReturnType<typeof setTimeout> | undefined;
            if (!authenticated) {
                authTimeout = setTimeout(() => {
                    if (!authenticated) {
                        this.wsSend(ws, { type: "error", error: "Auth timeout" });
                        ws.close(4001, "Auth timeout");
                    }
                }, 5000);
            } else {
                // Already authenticated via header — add to clients immediately
                this.wsClients.set(clientId, ws);
                logger.info("WebSocket client connected at /attach (header auth)", { clientId });
            }

            ws.on("message", async (rawData) => {
                let msg: any;
                try {
                    msg = JSON.parse(rawData.toString());
                } catch {
                    this.wsSend(ws, { type: "error", error: "Invalid JSON" });
                    return;
                }

                // Handle first-message auth for browser clients
                if (!authenticated) {
                    if (msg.type === "auth" && msg.token === this.config.token) {
                        authenticated = true;
                        if (authTimeout) clearTimeout(authTimeout);
                        this.wsClients.set(clientId, ws);
                        this.wsSend(ws, { type: "auth_ok" });
                        logger.info("WebSocket client connected at /attach (message auth)", { clientId });
                        return;
                    }
                    // Auth failed
                    if (authTimeout) clearTimeout(authTimeout);
                    this.wsSend(ws, { type: "error", error: "Unauthorized" });
                    ws.close(4003, "Unauthorized");
                    return;
                }

                if (!msg.type) {
                    this.wsSend(ws, { id: msg.id, type: "response", success: false, error: "Missing type" });
                    return;
                }

                if (!this.wsHandler) {
                    this.wsSend(ws, { id: msg.id, type: "response", success: false, error: "No handler configured" });
                    return;
                }

                try {
                    const { id, type, ...params } = msg;
                    const result = await this.wsHandler({ type, ...params }, clientId);
                    this.wsSend(ws, { id, type: "response", success: true, data: result });
                } catch (err) {
                    this.wsSend(ws, { id: msg.id, type: "response", success: false, error: String(err) });
                }
            });

            ws.on("close", () => {
                clearInterval(pingInterval);
                if (authTimeout) clearTimeout(authTimeout);
                this.wsClients.delete(clientId);
                logger.info("WebSocket client disconnected", { clientId });
            });

            ws.on("error", (err) => {
                clearInterval(pingInterval);
                if (authTimeout) clearTimeout(authTimeout);
                logger.error("WebSocket client error", { error: String(err), clientId });
                this.wsClients.delete(clientId);
            });
        });
    }

    /** Send JSON to a WebSocket client if still open */
    private wsSend(ws: WebSocket, data: any): void {
        if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(data));
        }
    }

    private authenticate(req: IncomingMessage): boolean {
        const auth = req.headers["authorization"];
        if (!auth) return false;

        const parts = auth.split(" ");
        if (parts.length !== 2 || parts[0] !== "Bearer") return false;

        return parts[1] === this.config.token;
    }

    private serveStatic(pathname: string, res: ServerResponse): void {
        // Default to index.html for root
        const filePath = pathname === "/"
            ? join(this.publicDir, "index.html")
            : join(this.publicDir, pathname);

        // Prevent directory traversal
        const resolved = resolve(filePath);
        if (!resolved.startsWith(this.publicDir)) {
            this.json(res, 403, { error: "Forbidden" });
            return;
        }

        if (!existsSync(resolved) || !statSync(resolved).isFile()) {
            this.json(res, 404, { error: "Not Found" });
            return;
        }

        const ext = extname(resolved);
        const contentType = MIME_TYPES[ext] ?? "application/octet-stream";

        res.writeHead(200, { "Content-Type": contentType });
        createReadStream(resolved).pipe(res);
    }

    private readJsonBody(req: IncomingMessage): Promise<any> {
        return new Promise((resolve, reject) => {
            let data = "";
            req.on("data", (chunk: Buffer) => { data += chunk.toString(); });
            req.on("end", () => {
                try {
                    resolve(JSON.parse(data));
                } catch {
                    reject(new Error("Invalid JSON"));
                }
            });
            req.on("error", reject);
        });
    }

    private isWebhookRateLimited(bucket: string, max: number): boolean {
        const now = Date.now();
        const timestamps = this.webhookRateLimits.get(bucket) ?? [];
        const recent = timestamps.filter((t) => now - t < WEBHOOK_RATE_WINDOW_MS);

        if (recent.length === 0) {
            this.webhookRateLimits.delete(bucket);
            // Still need to record this request
            this.webhookRateLimits.set(bucket, [now]);
            return false;
        }

        if (recent.length >= max) {
            this.webhookRateLimits.set(bucket, recent);
            return true;
        }

        recent.push(now);
        this.webhookRateLimits.set(bucket, recent);
        return false;
    }

    private recordAuthFailure(ip: string): void {
        const now = Date.now();
        const timestamps = this.authRateLimits.get(ip) ?? [];
        timestamps.push(now);
        this.authRateLimits.set(ip, timestamps);
    }

    private isAuthRateLimited(ip: string): boolean {
        const timestamps = this.authRateLimits.get(ip);
        if (!timestamps) return false;
        const now = Date.now();
        const recent = timestamps.filter((t) => now - t < AUTH_RATE_WINDOW_MS);

        if (recent.length === 0) {
            this.authRateLimits.delete(ip);
            return false;
        }

        this.authRateLimits.set(ip, recent);
        return recent.length >= AUTH_RATE_MAX;
    }

    private setCorsHeaders(res: ServerResponse): void {
        if (!this.config.cors) return;
        res.setHeader("Access-Control-Allow-Origin", this.config.cors.origin);
        res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
    }

    private json(res: ServerResponse, status: number, body: unknown): void {
        res.writeHead(status, { "Content-Type": "application/json" });
        res.end(JSON.stringify(body));
    }
}
